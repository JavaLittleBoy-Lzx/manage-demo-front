# æŠ€æœ¯æ¶æ„ä¸å·¥ç¨‹åŒ–å¢å¼ºå»ºè®®

## ğŸ“‹ å½“å‰æŠ€æœ¯ç°çŠ¶åˆ†æ

### ğŸ” é¡¹ç›®æŠ€æœ¯æ ˆç°çŠ¶
- **æ„å»ºå·¥å…·**: Vue CLI (webpack 4.x)
- **å¼€å‘è¯­è¨€**: JavaScript (ES6+)
- **çŠ¶æ€ç®¡ç†**: Vuex 4.x
- **HTTPå®¢æˆ·ç«¯**: Axios
- **å›¾è¡¨åº“**: vue-schart (è½»é‡çº§)

### âš ï¸ å‘ç°çš„æŠ€æœ¯å€ºåŠ¡
1. **é…ç½®ç®¡ç†**: ç¡¬ç¼–ç APIåœ°å€ï¼Œç¼ºä¹ç¯å¢ƒé…ç½®
2. **æ—¥å¿—ç®¡ç†**: å¤§é‡console.logè°ƒè¯•ï¼Œæ— ç»Ÿä¸€æ—¥å¿—ç³»ç»Ÿ
3. **é”™è¯¯å¤„ç†**: ç®€å•catchå¤„ç†ï¼Œç¼ºä¹é”™è¯¯æ”¶é›†å’Œåˆ†æ
4. **ä»£ç è´¨é‡**: ç¼ºä¹TypeScriptç±»å‹çº¦æŸå’Œé™æ€æ£€æŸ¥
5. **æµ‹è¯•è¦†ç›–**: æ— è‡ªåŠ¨åŒ–æµ‹è¯•ï¼Œä»…æœ‰æ‰‹åŠ¨åŠŸèƒ½æµ‹è¯•
6. **æ€§èƒ½ç›‘æ§**: ç¼ºä¹è¿è¡Œæ—¶æ€§èƒ½ç›‘æ§å’Œåˆ†æ

---

## ğŸ—ï¸ æ ¸å¿ƒæŠ€æœ¯æ¶æ„å‡çº§

### 1. æ„å»ºç³»ç»Ÿç°ä»£åŒ–

#### 1.1 ä» Vue CLI å‡çº§åˆ° Vite
```typescript
// vite.config.ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { resolve } from 'path'

export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src'),
      '@components': resolve(__dirname, 'src/components'),
      '@utils': resolve(__dirname, 'src/utils'),
      '@views': resolve(__dirname, 'src/views'),
      '@api': resolve(__dirname, 'src/api')
    }
  },
  build: {
    target: 'es2015',
    minify: 'terser',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          elementPlus: ['element-plus'],
          charts: ['echarts']
        }
      }
    }
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: process.env.VITE_API_BASE_URL,
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  }
})
```

**å‡çº§æ”¶ç›Š**:
- å¼€å‘æœåŠ¡å™¨å¯åŠ¨é€Ÿåº¦æå‡ 10-50x
- çƒ­æ›´æ–°é€Ÿåº¦æå‡ 3-5x
- æ„å»ºé€Ÿåº¦æå‡ 2-3x
- æ›´å¥½çš„ Tree Shaking

#### 1.2 TypeScript æ¸è¿›å¼è¿ç§»
```typescript
// types/api.ts - APIæ¥å£ç±»å‹å®šä¹‰
export interface BaseResponse<T = any> {
  code: number;
  message: string;
  data: T;
  success: boolean;
}

export interface PaginationParams {
  page: number;
  size: number;
  total?: number;
}

export interface ParkingSpace {
  id: string;
  spaceNumber: string;
  isOccupied: boolean;
  vehicleInfo?: VehicleInfo;
  lastUpdate: Date;
}

export interface VehicleInfo {
  plateNumber: string;
  ownerName: string;
  entryTime: Date;
  vehicleType: 'temporary' | 'monthly' | 'owner';
}

// utils/request.ts - ç±»å‹å®‰å…¨çš„è¯·æ±‚å°è£…
import type { BaseResponse } from '@/types/api'

class ApiClient {
  private instance: AxiosInstance;

  constructor() {
    this.instance = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL,
      timeout: 30000,
    });
    
    this.setupInterceptors();
  }

  async get<T>(url: string, params?: any): Promise<BaseResponse<T>> {
    const response = await this.instance.get(url, { params });
    return response.data;
  }

  async post<T>(url: string, data?: any): Promise<BaseResponse<T>> {
    const response = await this.instance.post(url, data);
    return response.data;
  }
}
```

#### 1.3 çŠ¶æ€ç®¡ç†å‡çº§ (Vuex â†’ Pinia)
```typescript
// stores/parking.ts
import { defineStore } from 'pinia'
import type { ParkingSpace, VehicleInfo } from '@/types/api'

export const useParkingStore = defineStore('parking', () => {
  const spaces = ref<ParkingSpace[]>([]);
  const currentVehicles = ref<VehicleInfo[]>([]);
  const loading = ref(false);

  // Getters
  const occupiedSpaces = computed(() => 
    spaces.value.filter(space => space.isOccupied)
  );
  
  const occupancyRate = computed(() => 
    spaces.value.length > 0 ? occupiedSpaces.value.length / spaces.value.length : 0
  );

  // Actions
  async function fetchParkingSpaces() {
    loading.value = true;
    try {
      const response = await apiClient.get<ParkingSpace[]>('/parking/spaces');
      spaces.value = response.data;
    } catch (error) {
      console.error('Failed to fetch parking spaces:', error);
      throw error;
    } finally {
      loading.value = false;
    }
  }

  return {
    spaces,
    currentVehicles,
    loading,
    occupiedSpaces,
    occupancyRate,
    fetchParkingSpaces
  };
});
```

### 2. é…ç½®ç®¡ç†ç³»ç»Ÿ

#### 2.1 ç¯å¢ƒé…ç½®æ ‡å‡†åŒ–
```typescript
// config/index.ts
interface AppConfig {
  apiBaseUrl: string;
  timeout: number;
  enableMock: boolean;
  logLevel: 'debug' | 'info' | 'warn' | 'error';
  features: {
    realTimeMonitoring: boolean;
    advancedAnalytics: boolean;
    exportFunctions: boolean;
  };
}

const configs: Record<string, AppConfig> = {
  development: {
    apiBaseUrl: 'http://www.xuerparking.cn:8543',
    timeout: 30000,
    enableMock: false,
    logLevel: 'debug',
    features: {
      realTimeMonitoring: true,
      advancedAnalytics: true,
      exportFunctions: true
    }
  },
  staging: {
    apiBaseUrl: 'https://staging-api.parking.com',
    timeout: 15000,
    enableMock: false,
    logLevel: 'info',
    features: {
      realTimeMonitoring: true,
      advancedAnalytics: true,
      exportFunctions: true
    }
  },
  production: {
    apiBaseUrl: 'https://api.parking.com',
    timeout: 10000,
    enableMock: false,
    logLevel: 'error',
    features: {
      realTimeMonitoring: true,
      advancedAnalytics: false,
      exportFunctions: true
    }
  }
};

export const config = configs[import.meta.env.MODE] || configs.development;
```

#### 2.2 åŠŸèƒ½å¼€å…³ç³»ç»Ÿ
```typescript
// utils/featureFlags.ts
class FeatureFlags {
  private flags: Map<string, boolean> = new Map();

  constructor() {
    this.loadFlags();
  }

  private async loadFlags() {
    try {
      const response = await fetch('/api/feature-flags');
      const flags = await response.json();
      Object.entries(flags).forEach(([key, value]) => {
        this.flags.set(key, value as boolean);
      });
    } catch {
      // ä½¿ç”¨é»˜è®¤é…ç½®
      this.loadDefaultFlags();
    }
  }

  isEnabled(flagName: string): boolean {
    return this.flags.get(flagName) ?? false;
  }

  enable(flagName: string): void {
    this.flags.set(flagName, true);
  }

  disable(flagName: string): void {
    this.flags.set(flagName, false);
  }
}

export const featureFlags = new FeatureFlags();

// åœ¨ç»„ä»¶ä¸­ä½¿ç”¨
export function useFeatureFlag(flagName: string) {
  return computed(() => featureFlags.isEnabled(flagName));
}
```

### 3. æ—¥å¿—ç®¡ç†ç³»ç»Ÿ

#### 3.1 ç»Ÿä¸€æ—¥å¿—æœåŠ¡
```typescript
// utils/logger.ts
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: Date;
  component?: string;
  userId?: string;
  sessionId: string;
  extra?: Record<string, any>;
}

class Logger {
  private currentLevel: LogLevel;
  private sessionId: string;
  private buffer: LogEntry[] = [];
  private maxBufferSize = 100;

  constructor(level: LogLevel = LogLevel.INFO) {
    this.currentLevel = level;
    this.sessionId = this.generateSessionId();
    this.setupErrorHandling();
  }

  private setupErrorHandling() {
    window.addEventListener('error', (event) => {
      this.error('Global Error', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
    });

    window.addEventListener('unhandledrejection', (event) => {
      this.error('Unhandled Promise Rejection', {
        reason: event.reason
      });
    });
  }

  debug(message: string, extra?: Record<string, any>) {
    this.log(LogLevel.DEBUG, message, extra);
  }

  info(message: string, extra?: Record<string, any>) {
    this.log(LogLevel.INFO, message, extra);
  }

  warn(message: string, extra?: Record<string, any>) {
    this.log(LogLevel.WARN, message, extra);
  }

  error(message: string, extra?: Record<string, any>) {
    this.log(LogLevel.ERROR, message, extra);
  }

  private log(level: LogLevel, message: string, extra?: Record<string, any>) {
    if (level < this.currentLevel) return;

    const entry: LogEntry = {
      level,
      message,
      timestamp: new Date(),
      sessionId: this.sessionId,
      extra
    };

    // æ·»åŠ åˆ°ç¼“å†²åŒº
    this.buffer.push(entry);
    if (this.buffer.length > this.maxBufferSize) {
      this.buffer.shift();
    }

    // æ§åˆ¶å°è¾“å‡º
    this.outputToConsole(entry);

    // å‘é€åˆ°è¿œç¨‹æ—¥å¿—æœåŠ¡
    if (level >= LogLevel.WARN) {
      this.sendToRemote(entry);
    }
  }

  private async sendToRemote(entry: LogEntry) {
    try {
      await fetch('/api/logs', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(entry)
      });
    } catch (error) {
      console.error('Failed to send log to remote:', error);
    }
  }
}

export const logger = new Logger();
```

#### 3.2 æ€§èƒ½ç›‘æ§
```typescript
// utils/performance.ts
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  measureFunction<T>(name: string, fn: () => T): T {
    const start = performance.now();
    const result = fn();
    const duration = performance.now() - start;
    
    this.recordMetric(name, duration);
    logger.debug(`Performance: ${name} took ${duration.toFixed(2)}ms`);
    
    return result;
  }

  async measureAsyncFunction<T>(name: string, fn: () => Promise<T>): Promise<T> {
    const start = performance.now();
    try {
      const result = await fn();
      const duration = performance.now() - start;
      this.recordMetric(name, duration);
      logger.debug(`Performance: ${name} took ${duration.toFixed(2)}ms`);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      logger.error(`Performance: ${name} failed after ${duration.toFixed(2)}ms`, { error });
      throw error;
    }
  }

  private recordMetric(name: string, value: number) {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    const values = this.metrics.get(name)!;
    values.push(value);
    
    // ä¿æŒæœ€è¿‘100æ¡è®°å½•
    if (values.length > 100) {
      values.shift();
    }
  }

  getMetrics() {
    const result: Record<string, { avg: number; min: number; max: number; count: number }> = {};
    
    this.metrics.forEach((values, name) => {
      const avg = values.reduce((a, b) => a + b, 0) / values.length;
      const min = Math.min(...values);
      const max = Math.max(...values);
      
      result[name] = { avg, min, max, count: values.length };
    });
    
    return result;
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

### 4. é”™è¯¯å¤„ç†ä¸ç›‘æ§

#### 4.1 å…¨å±€é”™è¯¯å¤„ç†
```typescript
// utils/errorHandler.ts
interface ErrorInfo {
  message: string;
  stack?: string;
  component?: string;
  action?: string;
  timestamp: Date;
  userId?: string;
  url: string;
  userAgent: string;
}

class ErrorHandler {
  private errorQueue: ErrorInfo[] = [];
  private readonly maxQueueSize = 50;

  constructor() {
    this.setupGlobalHandlers();
  }

  private setupGlobalHandlers() {
    // Vueé”™è¯¯å¤„ç†
    const app = getCurrentInstance()?.appContext.app;
    if (app) {
      app.config.errorHandler = (error, instance, info) => {
        this.handleError(error, {
          component: instance?.$options.name || 'Unknown',
          action: info
        });
      };
    }

    // Promiseæ‹’ç»å¤„ç†
    window.addEventListener('unhandledrejection', (event) => {
      this.handleError(new Error(event.reason), {
        action: 'unhandledrejection'
      });
    });
  }

  handleError(error: Error, context?: Partial<ErrorInfo>) {
    const errorInfo: ErrorInfo = {
      message: error.message,
      stack: error.stack,
      timestamp: new Date(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      ...context
    };

    // è®°å½•é”™è¯¯
    logger.error('Application Error', errorInfo);

    // æ·»åŠ åˆ°é˜Ÿåˆ—
    this.errorQueue.push(errorInfo);
    if (this.errorQueue.length > this.maxQueueSize) {
      this.errorQueue.shift();
    }

    // å‘é€åˆ°é”™è¯¯ç›‘æ§æœåŠ¡
    this.reportError(errorInfo);

    // ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
    this.showUserFriendlyError(error);
  }

  private async reportError(errorInfo: ErrorInfo) {
    try {
      await fetch('/api/errors', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(errorInfo)
      });
    } catch (reportError) {
      console.error('Failed to report error:', reportError);
    }
  }

  private showUserFriendlyError(error: Error) {
    // æ ¹æ®é”™è¯¯ç±»å‹æ˜¾ç¤ºä¸åŒçš„ç”¨æˆ·æç¤º
    if (error.message.includes('Network')) {
      ElMessage.error('ç½‘ç»œè¿æ¥å¼‚å¸¸ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•');
    } else if (error.message.includes('Permission')) {
      ElMessage.error('æƒé™ä¸è¶³ï¼Œè¯·è”ç³»ç®¡ç†å‘˜');
    } else {
      ElMessage.error('ç³»ç»Ÿå¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•');
    }
  }
}

export const errorHandler = new ErrorHandler();
```

#### 4.2 APIé”™è¯¯å¤„ç†å¢å¼º
```typescript
// utils/apiErrorHandler.ts
export enum ApiErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  NOT_FOUND = 'NOT_FOUND',
  SERVER_ERROR = 'SERVER_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR'
}

export class ApiError extends Error {
  constructor(
    public code: ApiErrorCode,
    message: string,
    public originalError?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export function setupApiInterceptors(axiosInstance: AxiosInstance) {
  // è¯·æ±‚æ‹¦æˆªå™¨
  axiosInstance.interceptors.request.use(
    (config) => {
      const requestId = generateRequestId();
      config.metadata = { requestId, startTime: Date.now() };
      
      logger.debug('API Request', {
        requestId,
        method: config.method?.toUpperCase(),
        url: config.url,
        params: config.params,
        data: config.data
      });
      
      return config;
    },
    (error) => {
      logger.error('Request Error', error);
      return Promise.reject(error);
    }
  );

  // å“åº”æ‹¦æˆªå™¨
  axiosInstance.interceptors.response.use(
    (response) => {
      const duration = Date.now() - response.config.metadata.startTime;
      
      logger.debug('API Response', {
        requestId: response.config.metadata.requestId,
        status: response.status,
        duration,
        url: response.config.url
      });
      
      return response;
    },
    (error) => {
      const apiError = transformError(error);
      
      logger.error('API Error', {
        requestId: error.config?.metadata?.requestId,
        code: apiError.code,
        message: apiError.message,
        url: error.config?.url,
        status: error.response?.status
      });
      
      return Promise.reject(apiError);
    }
  );
}

function transformError(error: any): ApiError {
  if (error.code === 'ECONNABORTED') {
    return new ApiError(ApiErrorCode.TIMEOUT, 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•', error);
  }
  
  if (!error.response) {
    return new ApiError(ApiErrorCode.NETWORK_ERROR, 'ç½‘ç»œè¿æ¥å¤±è´¥', error);
  }
  
  const { status, data } = error.response;
  
  switch (status) {
    case 401:
      return new ApiError(ApiErrorCode.UNAUTHORIZED, 'è¯·é‡æ–°ç™»å½•', error);
    case 403:
      return new ApiError(ApiErrorCode.FORBIDDEN, 'æƒé™ä¸è¶³', error);
    case 404:
      return new ApiError(ApiErrorCode.NOT_FOUND, 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨', error);
    case 422:
      return new ApiError(ApiErrorCode.VALIDATION_ERROR, data.message || 'æ•°æ®éªŒè¯å¤±è´¥', error);
    default:
      return new ApiError(ApiErrorCode.SERVER_ERROR, 'æœåŠ¡å™¨å¼‚å¸¸', error);
  }
}
```

### 5. ä»£ç è´¨é‡ä¿éšœ

#### 5.1 é™æ€ä»£ç åˆ†æ
```json
// .eslintrc.js
module.exports = {
  extends: [
    '@vue/typescript/recommended',
    '@vue/prettier',
    '@vue/prettier/@typescript-eslint'
  ],
  rules: {
    // ä»£ç è´¨é‡è§„åˆ™
    'no-console': process.env.NODE_ENV === 'production' ? 'error' : 'warn',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'error' : 'warn',
    'prefer-const': 'error',
    'no-var': 'error',
    
    // Vueç‰¹å®šè§„åˆ™
    'vue/multi-word-component-names': 'error',
    'vue/no-unused-vars': 'error',
    'vue/component-definition-name-casing': ['error', 'PascalCase'],
    
    // TypeScriptè§„åˆ™
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/explicit-function-return-type': 'warn',
    '@typescript-eslint/no-explicit-any': 'warn'
  }
};
```

#### 5.2 ä»£ç æ ¼å¼åŒ–
```json
// prettier.config.js
module.exports = {
  semi: true,
  singleQuote: true,
  tabWidth: 2,
  trailingComma: 'es5',
  printWidth: 100,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf'
};
```

#### 5.3 Git Hooks é…ç½®
```json
// package.json
{
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged",
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }
  },
  "lint-staged": {
    "*.{js,ts,vue}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{css,scss,vue}": [
      "stylelint --fix",
      "prettier --write"
    ]
  }
}
```

### 6. è‡ªåŠ¨åŒ–æµ‹è¯•ä½“ç³»

#### 6.1 å•å…ƒæµ‹è¯•
```typescript
// tests/unit/stores/parking.spec.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { setActivePinia, createPinia } from 'pinia';
import { useParkingStore } from '@/stores/parking';

describe('Parking Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia());
  });

  it('should calculate occupancy rate correctly', () => {
    const store = useParkingStore();
    
    store.spaces = [
      { id: '1', spaceNumber: 'A01', isOccupied: true },
      { id: '2', spaceNumber: 'A02', isOccupied: false },
      { id: '3', spaceNumber: 'A03', isOccupied: true },
      { id: '4', spaceNumber: 'A04', isOccupied: false }
    ];

    expect(store.occupancyRate).toBe(0.5);
  });

  it('should fetch parking spaces successfully', async () => {
    const store = useParkingStore();
    
    // Mock API response
    vi.mocked(apiClient.get).mockResolvedValue({
      code: 200,
      data: [
        { id: '1', spaceNumber: 'A01', isOccupied: false }
      ],
      message: 'Success',
      success: true
    });

    await store.fetchParkingSpaces();

    expect(store.spaces).toHaveLength(1);
    expect(store.loading).toBe(false);
  });
});
```

#### 6.2 é›†æˆæµ‹è¯•
```typescript
// tests/integration/api.spec.ts
import { describe, it, expect } from 'vitest';
import { apiClient } from '@/utils/request';

describe('API Integration', () => {
  it('should handle authentication flow', async () => {
    // æµ‹è¯•ç™»å½•
    const loginResponse = await apiClient.post('/auth/login', {
      username: 'test@example.com',
      password: 'password123'
    });

    expect(loginResponse.success).toBe(true);
    expect(loginResponse.data.token).toBeDefined();

    // æµ‹è¯•å—ä¿æŠ¤çš„æ¥å£
    const protectedResponse = await apiClient.get('/user/profile');
    expect(protectedResponse.success).toBe(true);
  });
});
```

#### 6.3 E2Eæµ‹è¯•
```typescript
// tests/e2e/parking-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Parking Management', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login');
    await page.fill('[data-testid="username"]', 'admin@example.com');
    await page.fill('[data-testid="password"]', 'password123');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('/dashboard');
  });

  test('should display parking spaces correctly', async ({ page }) => {
    await page.goto('/parking/spaces');
    
    await expect(page.locator('[data-testid="parking-grid"]')).toBeVisible();
    await expect(page.locator('[data-testid="space-card"]')).toHaveCount(100);
  });

  test('should create new vehicle entry', async ({ page }) => {
    await page.goto('/parking/entry');
    
    await page.fill('[data-testid="plate-number"]', 'ABC123');
    await page.selectOption('[data-testid="vehicle-type"]', 'temporary');
    await page.click('[data-testid="submit-button"]');
    
    await expect(page.locator('[data-testid="success-message"]')).toBeVisible();
  });
});
```

### 7. ç›‘æ§ä¸è¿ç»´

#### 7.1 åº”ç”¨æ€§èƒ½ç›‘æ§ (APM)
```typescript
// utils/apm.ts
interface Metric {
  name: string;
  value: number;
  timestamp: Date;
  tags?: Record<string, string>;
}

class APMCollector {
  private metrics: Metric[] = [];
  private readonly batchSize = 10;
  private readonly flushInterval = 30000; // 30ç§’

  constructor() {
    this.startPeriodicFlush();
    this.collectVitals();
  }

  recordMetric(name: string, value: number, tags?: Record<string, string>) {
    this.metrics.push({
      name,
      value,
      timestamp: new Date(),
      tags
    });

    if (this.metrics.length >= this.batchSize) {
      this.flush();
    }
  }

  private async flush() {
    if (this.metrics.length === 0) return;

    const metricsToSend = [...this.metrics];
    this.metrics = [];

    try {
      await fetch('/api/metrics', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(metricsToSend)
      });
    } catch (error) {
      logger.error('Failed to send metrics', { error });
      // å¦‚æœå‘é€å¤±è´¥ï¼Œé‡æ–°åŠ å…¥é˜Ÿåˆ—
      this.metrics.unshift(...metricsToSend);
    }
  }

  private collectVitals() {
    // æ”¶é›†æ ¸å¿ƒWebæŒ‡æ ‡
    new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'largest-contentful-paint') {
          this.recordMetric('web.lcp', entry.value, { page: location.pathname });
        }
        if (entry.entryType === 'first-input') {
          this.recordMetric('web.fid', entry.value, { page: location.pathname });
        }
      });
    }).observe({ entryTypes: ['largest-contentful-paint', 'first-input'] });

    // æ”¶é›†è·¯ç”±åˆ‡æ¢æ€§èƒ½
    router.beforeEach((to, from) => {
      const startTime = performance.now();
      router.afterEach(() => {
        const duration = performance.now() - startTime;
        this.recordMetric('route.navigation', duration, {
          from: from.path,
          to: to.path
        });
      });
    });
  }
}

export const apm = new APMCollector();
```

#### 7.2 å®æ—¶æ€§èƒ½ä»ªè¡¨ç›˜
```typescript
// components/PerformanceDashboard.vue
<template>
  <div class="performance-dashboard">
    <el-card title="ç³»ç»Ÿæ€§èƒ½ç›‘æ§">
      <el-row :gutter="16">
        <el-col :span="6">
          <el-statistic title="é¡µé¢åŠ è½½æ—¶é—´" :value="metrics.averageLoadTime" suffix="ms" />
        </el-col>
        <el-col :span="6">
          <el-statistic title="APIå“åº”æ—¶é—´" :value="metrics.averageApiTime" suffix="ms" />
        </el-col>
        <el-col :span="6">
          <el-statistic title="é”™è¯¯ç‡" :value="metrics.errorRate" suffix="%" />
        </el-col>
        <el-col :span="6">
          <el-statistic title="æ´»è·ƒç”¨æˆ·" :value="metrics.activeUsers" />
        </el-col>
      </el-row>
      
      <div class="charts-container">
        <performance-chart :data="chartData" />
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
const metrics = ref({
  averageLoadTime: 0,
  averageApiTime: 0,
  errorRate: 0,
  activeUsers: 0
});

const chartData = ref([]);

onMounted(() => {
  fetchMetrics();
  setInterval(fetchMetrics, 30000); // æ¯30ç§’æ›´æ–°
});

async function fetchMetrics() {
  try {
    const response = await apiClient.get('/metrics/dashboard');
    metrics.value = response.data;
    chartData.value = response.data.chartData;
  } catch (error) {
    logger.error('Failed to fetch metrics', error);
  }
}
</script>
```

---

## ğŸš€ å®æ–½è®¡åˆ’

### Phase 1: åŸºç¡€è®¾æ–½å‡çº§ (4-6å‘¨)
1. **Vite + TypeScript è¿ç§»** (2å‘¨)
   - é…ç½®Viteæ„å»ºç¯å¢ƒ
   - é€æ­¥è¿ç§»å…³é”®ç»„ä»¶åˆ°TypeScript
   
2. **æ—¥å¿—å’Œé”™è¯¯å¤„ç†ç³»ç»Ÿ** (2å‘¨)
   - å®ç°ç»Ÿä¸€æ—¥å¿—æœåŠ¡
   - é…ç½®å…¨å±€é”™è¯¯å¤„ç†
   
3. **é…ç½®ç®¡ç†æ ‡å‡†åŒ–** (1å‘¨)
   - ç¯å¢ƒé…ç½®åˆ†ç¦»
   - åŠŸèƒ½å¼€å…³ç³»ç»Ÿ

### Phase 2: å¼€å‘ä½“éªŒä¼˜åŒ– (3-4å‘¨)
1. **çŠ¶æ€ç®¡ç†å‡çº§** (1.5å‘¨)
   - Vuex to Pinia è¿ç§»
   - ç±»å‹å®‰å…¨çš„çŠ¶æ€ç®¡ç†
   
2. **ä»£ç è´¨é‡å·¥å…·** (1å‘¨)
   - ESLint + Prettier é…ç½®
   - Git Hooks è®¾ç½®
   
3. **APIå±‚é‡æ„** (1.5å‘¨)
   - ç±»å‹å®‰å…¨çš„APIå®¢æˆ·ç«¯
   - ç»Ÿä¸€é”™è¯¯å¤„ç†

### Phase 3: æµ‹è¯•ä½“ç³»å»ºè®¾ (4-5å‘¨)
1. **å•å…ƒæµ‹è¯•æ¡†æ¶** (2å‘¨)
   - Vitest é…ç½®
   - æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯•
   
2. **é›†æˆæµ‹è¯•** (1.5å‘¨)
   - APIé›†æˆæµ‹è¯•
   - çŠ¶æ€ç®¡ç†æµ‹è¯•
   
3. **E2Eæµ‹è¯•** (1.5å‘¨)
   - Playwright é…ç½®
   - å…³é”®ä¸šåŠ¡æµç¨‹æµ‹è¯•

### Phase 4: ç›‘æ§è¿ç»´ (3-4å‘¨)
1. **æ€§èƒ½ç›‘æ§** (2å‘¨)
   - APMç³»ç»Ÿé›†æˆ
   - æ€§èƒ½æŒ‡æ ‡æ”¶é›†
   
2. **è¿ç»´ä»ªè¡¨ç›˜** (2å‘¨)
   - å®æ—¶ç›‘æ§ç•Œé¢
   - å‘Šè­¦æœºåˆ¶

---

## ğŸ“Š æŠ•èµ„å›æŠ¥åˆ†æ

### å¼€å‘æ•ˆç‡æå‡
- **æ„å»ºé€Ÿåº¦æå‡**: 80-90% (Vite)
- **ç±»å‹é”™è¯¯å‡å°‘**: 60-70% (TypeScript)
- **è°ƒè¯•æ•ˆç‡æå‡**: 50-60% (ç»Ÿä¸€æ—¥å¿—)
- **ä»£ç è´¨é‡æå‡**: 40-50% (é™æ€åˆ†æ)

### ç³»ç»Ÿç¨³å®šæ€§æå‡
- **è¿è¡Œæ—¶é”™è¯¯å‡å°‘**: 50-70%
- **æ•…éšœå®šä½æ—¶é—´ç¼©çŸ­**: 60-80%
- **ç³»ç»Ÿå¯ç”¨æ€§æå‡**: 99.5%+

### å›¢é˜Ÿåä½œæ•ˆç‡
- **ä»£ç å®¡æŸ¥æ•ˆç‡**: 40-60%
- **æ–°äººä¸Šæ‰‹æ—¶é—´**: 30-50%
- **çŸ¥è¯†ä¼ é€’æ•ˆç‡**: 50-70%

### é•¿æœŸç»´æŠ¤æˆæœ¬
- **Bugä¿®å¤æ—¶é—´**: 40-60%
- **æ–°åŠŸèƒ½å¼€å‘é€Ÿåº¦**: 30-50%
- **æŠ€æœ¯å€ºåŠ¡æ¸…ç†**: 70-80%

---

## ğŸ¯ å…³é”®æˆåŠŸå› ç´ 

1. **å›¢é˜ŸæŠ€èƒ½å»ºè®¾**
   - TypeScriptåŸ¹è®­
   - ç°ä»£å‰ç«¯å·¥ç¨‹åŒ–å®è·µ
   - æµ‹è¯•é©±åŠ¨å¼€å‘

2. **æ¸è¿›å¼è¿ç§»ç­–ç•¥**
   - ä¸å½±å“ç°æœ‰åŠŸèƒ½
   - åˆ†æ¨¡å—é€æ­¥å‡çº§
   - å……åˆ†æµ‹è¯•éªŒè¯

3. **è´¨é‡ä¿éšœæœºåˆ¶**
   - å®Œå–„çš„æµ‹è¯•è¦†ç›–
   - è‡ªåŠ¨åŒ–CI/CDæµç¨‹
   - æŒç»­çš„ä»£ç å®¡æŸ¥

4. **ç›‘æ§å’Œåé¦ˆ**
   - å…¨é¢çš„æ€§èƒ½ç›‘æ§
   - åŠæ—¶çš„é—®é¢˜å‘ç°
   - å¿«é€Ÿçš„å“åº”æœºåˆ¶

é€šè¿‡è¿™äº›æŠ€æœ¯å‡çº§ï¼Œæ‚¨çš„åœè½¦ç®¡ç†ç³»ç»Ÿå°†å…·å¤‡ç°ä»£åŒ–çš„æŠ€æœ¯æ¶æ„ã€å®Œå–„çš„å·¥ç¨‹åŒ–ä½“ç³»å’Œå¼ºå¤§çš„ç›‘æ§è¿ç»´èƒ½åŠ›ï¼Œä¸ºä¸šåŠ¡å‘å±•æä¾›åšå®çš„æŠ€æœ¯åŸºç¡€ã€‚ 